---
title: "lecture 12"
author: "Yi Chen(yc3356)"
date: "December 1, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## lecture 12: split, apply and combine

### apply function famliy
```{r}
setwd("C:/Users/cheny/Desktop/study/statistical computing and intro to data science/lecture/lecture 12")

strikes <- read.csv('strikes.csv',as.is = TRUE)
head(strikes)
dim(strikes)
```

1.split

split(x, f = my.index) 
```{r}
strikes.split <- split(strikes,f=strikes$country)

sapply(strikes.split,dim)

calculte_mean <- function(x){
        return(mean(x$unemployment,na.rm = TRUE))
}
mean.unemploy <- sapply(strikes.split,calculte_mean)

mean.unemploy[which.max(mean.unemploy)]

mean.unemploy[which.min(mean.unemploy)]
```

```{r}
# single country

italy.strikes <- strikes[strikes$country=='Italy',]
# equally
italy.strikes <- subset(strikes,country=='Italy')


dim(italy.strikes)

italy.fit <- lm(strike.volume ~ left.parliament,data =italy.strikes)

italy.fit

plot(strike.volume ~left.parliament, data = italy.strikes,main = "Italy Strike Volume Versus Leftwing Alignment",ylab = "Strike volume", xlab ="Leftwing Alignment")
abline(italy.fit, col = 2)

library(ggplot2)
ggplot(data=italy.strikes)+
        geom_point(y=strike.volume,x=left.parliament)+
        labs(title="Italy Strike Volume Versus Leftwing Alignment",y = "Strike volume", x ="Leftwing Alignment")

```

```{r}
my.strike.lm <- function(country.df) {
        return(lm(strike.volume ~ left.parliament,data = country.df)$coeff)
}
my.strike.lm(subset(strikes, country == "Italy"))

strike.coef <- NULL
countries <- unique(strikes$country)

for (this.country in countries) {
        country.dat <- subset(strikes, country == this.country)
        new.coefs <- my.strike.lm(country.dat)
        strike.coef <- cbind(strike.coef, new.coefs)
}

colnames(strike.coef) <- countries
strike.coef

```

```{r}
# a smarter way to do the same task
strikes.split <- split(strikes,strikes$country)

strike.coef <- sapply(strikes.split,my.strike.lm)
strike.coef

plot(1:ncol(strike.coef), strike.coef[2, ], xaxt = "n",xlab = "", ylab = "Regression coefficient",main="Countrywise labor activity by leftwing score")
axis(side = 1, at = 1:ncol(strike.coef),
labels = colnames(strike.coef), las = 2,
cex.axis = 0.5)
abline(h = 0, col = "grey")

```

```{r}
# test
strike.year <- split(strikes,strikes$year)

three.mean <- function(df){
        return(apply(df[,c('unemployment','inflation','strike.volume')],2,mean))
}

year.mat <- sapply(strike.year,three.mean)

max.rate <- max(year.mat)
min.rate <- min(year.mat)
plot(colnames(year.mat),year.mat[2,],type = 'l',col='red',xlab='year',ylab='rate')
points(colnames(year.mat),year.mat[1,],type = 'l',col='black',xlab='year',ylab='rate')
legend('topleft',c('unemployment','inflation'),fill=c('black','red'))

```

```{r}
my.array <- array(1:27, c(3,3,3))
rownames(my.array) <- c("R1", "R2", "R3")
colnames(my.array) <- c("C1", "C2", "C3")
dimnames(my.array)[[3]] <- c("Bart", "Lisa", "Maggie")

my.array
my.array[, , 3]

library(plyr)
aaply(my.array,1,sum) # get back an array
adply(my.array,1,sum) # get back a dataframe
alply(my.array,1,sum) # get back a list

aaply(my.array, 2:3, sum) # Get back a 3 x 3 array
adply(my.array, 2:3, sum) # Get back a data frame
alply(my.array, 2:3, sum) # Get back a list

my.array[,3,]
```

```{r}
my.list <- list(nums = rnorm(1000), lets = letters,pops = state.x77[ ,"Population"])
head(my.list[[1]], 5)
head(my.list[[2]], 5)
head(my.list[[3]], 5)
laply(my.list, range) # Get back an array
ldply(my.list, range) # Get back a data frame
llply(my.list, range) # Get back a list
# Doesn't work! Outputs have different types/lengths
# laply(my.list, summary)
# ldply(my.list, summary)
llply(my.list, summary) # Works just fine

```

```{r}
par(mfrow = c(3, 3), mar = c(4, 4, 1, 1))
a_ply(my.array, 2:3, plot, ylim = range(my.array),pch = 19, col = 6)
```

```{r}
# D_ply
# Function to compute coefficients from regressing number
# of strikes (per 1000 workers) on leftwing share of the
# government
my.strike.lm <- function(country.df) {
        return(coef(lm(strike.volume ~ left.parliament,data = country.df)))
}
# Getting regression coefficients separately
# for each country, old way:
strikes.list <- split(strikes, f = strikes$country)
strikes.coefs <- sapply(strikes.list, my.strike.lm)
strikes.coefs[, 1:12]

# Getting regression coefficient separately for each
# country, new way, in three formats:
strike.coef.a <- daply(strikes, .(country), my.strike.lm)
# Get back an array, note the difference to sapply()
head(strike.coef.a)
strike.coef.d <- ddply(strikes, .(country), my.strike.lm)
head(strike.coef.d) # Get back a data frame
strike.coef.l <- dlply(strikes, .(country), my.strike.lm)
head(strike.coef.l, 3) # Get back a list

```

```{r}
# First create a variable that indicates whether the year
# is pre 1975, and add it to the data frame
strikes$yearPre1975 <- strikes$year <= 1975
# Then use (say) ddply() to compute regression
# coefficients for each country pre & post 1975
strike.coef.75 <- ddply(strikes, .(country, yearPre1975),
my.strike.lm)
dim(strike.coef.75) # Note there are 18 x 2 = 36 rows
head(strike.coef.75)


strike.coef.75 <-ddply(strikes,.(country,I(year<=1975)),my.strike.lm)
dim(strike.coef.75) # Again, 18 x 2 = 36 rows
head(strike.coef.75)

```

```{r}
#task
inflation.mean <- function(df){
        return(mean(df$inflation,na.rm = TRUE))
}

strike.mean.country.year <- ddply(strikes,.(country,I(year<1975)),inflation.mean)

strike.mean.country.year

split.list <- list(strikes$country,I(strikes$year<=1975))
data.split <- split(strikes,split.list)
inflation.mean <- sapply(data.split,inflation.mean)
inflation.mean
```

```{r}
library(dplyr)
ycs <- select(strikes, year, country, strike.volume)
head(ycs)
# Same as
ycs <- strikes[, c("year", "country", "strike.volume")]

strikes %>% select(year, country, strike.volume) 
                                                

```

```{r}
ycs <- strikes %>% select(year, country, strike.volume)
# Maybe we're only interested in strikes where the unemployment
# is greater than 4 percent
ycs_unemploy <- strikes %>%
        filter(unemployment > 4) %>%
        select(year, country, strike.volume)

head(ycs_unemploy)
dim(ycs)
dim(ycs_unemploy)
# Note that the order matters!

```

```{r}
# group_by acts like split
# Most useful when combined with summarize
strikes.split <- strikes %>% 
        group_by(country)
country.strikes <- strikes %>%
        group_by(country) %>%
        summarize(avg.str = mean(strike.volume),minaa= min(strike.volume))
country.strikes
```

```{r}
# reshape
snoq <- read.csv("snoqualmie.csv", header = FALSE,as.is = TRUE)
colnames(snoq) <- 1:366
snoq$year <- 1948:1983
snoq[1:3, 360:367]
#install.packages("reshape2")
require(reshape2)
snoq.melt <- melt(snoq, id.vars = "year", variable.name = "day",
value.name = "precip")
head(snoq.melt)
tail(snoq.melt)
dim(snoq.melt) # 36*366

snoq.melt.chron <- snoq.melt[order(snoq.melt$year,snoq.melt$day),]

head(snoq.melt.chron)

plot(snoq.melt.chron)

```

```{r}
leap.days <- snoq.melt.chron$day == 366
sum(is.na(snoq.melt.chron$precip[leap.days]))

snoq.melt.chron <- na.omit(snoq.melt.chron)


short.chron <- snoq.melt.chron[-nrow(snoq.melt.chron), ]
precip.next <- snoq.melt.chron$precip[-1]
snoq.pairs <- data.frame(short.chron, precip.next)
head(snoq.pairs)

```

