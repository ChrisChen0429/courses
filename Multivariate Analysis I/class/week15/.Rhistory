# Simulated data example
# Let's generate 3 groups from bivariate normal distribution:
library(MASS)
set.seed(439)
g1 = mvrnorm(n = 25, mu = c(10, 20), Sigma = matrix(c(6, -4, -4, 10), 2, 2))
plot(g1, pch = 19, col = "blue", xlim = c(0, 40), ylim = c(0, 30), xlab = "x", ylab = "y")
g2 = mvrnorm(n = 25, mu = c(20, 10), Sigma = matrix(c(6, -4, -4, 10), 2, 2))
points(g2, pch = 19)
g3 = mvrnorm(n = 25, mu = c(27, 20), Sigma = matrix(c(7, 4, 4, 12), 2, 2))
points(g3, pch = 19, col = "red")
# What the algorithm sees:
d = rbind(g1, g2, g3)
plot(d, pch = 19, col = "grey", cex = 0.9, xlab = "x", ylab = "y")
# Choose randomly 3 initial centers:
n = nrow(d)
(cen.ind = sample(1:n, 3))
(cen = d[cen.ind,])
points(cen, col =c ("black", "blue", "red"), pch = 2, cex = 1.5)
# Assign each observation to one of the 3 groups:
for (i in 1:n)
{
# New data with row i and centers:
d.cen = rbind(d[i,], cen)
# Distance to each center:
dist.cen = dist(d.cen)
# Convert to matrix so we can use only specific column:
dist.cen = as.matrix(dist.cen)
if (which.min(dist.cen[1, 2:4]) == 1) points(d[i,1], d[i,2], pch = 2)
if (which.min(dist.cen[1, 2:4]) == 2) points(d[i,1], d[i,2], pch = 2, col = "blue")
if (which.min(dist.cen[1, 2:4]) == 3) points(d[i,1], d[i,2], pch = 2, col = "red")
}
# Built-in function:
kmeans(d, cen)
# Iterations:
kmeans(d, cen)$iter
# Partitioning
kmeans(d, cen)$cluster
# Plot together the true groups with the clusters
par(mfrow = c(1, 2))
plot(d, pch = 19, col = "grey", cex = 0.9, xlab = "x", ylab = "y")
points(d[kmeans(d, cen)$cluster == 1,], pch = 2)
points(d[kmeans(d, cen)$cluster == 2,], pch = 2, col = "red")
points(d[kmeans(d, cen)$cluster == 3,], pch = 2, col = "blue")
# True groups:
plot(g1, pch = 19, col = "blue", xlim = c(0, 40), ylim = c(0, 30), xlab = "x", ylab = "y")
points(g2, pch = 19)
points(g3, pch = 19, col = "red")
par(mfrow = c(1, 1))
## Example with Table 15.7 from Rencher
# Load file T15_7_PROTEIN.dat
d = read.table(file.choose(), header = F)
